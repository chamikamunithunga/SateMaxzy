const OpenAI = require('openai');
const { GoogleGenerativeAI } = require('@google/generative-ai');

class ReportService {
  constructor() {
    // Initialize AI clients (will be undefined if no API keys)
    this.openai = process.env.OPENAI_API_KEY ? new OpenAI({ apiKey: process.env.OPENAI_API_KEY }) : null;
    this.gemini = process.env.GEMINI_API_KEY ? new GoogleGenerativeAI(process.env.GEMINI_API_KEY) : null;
  }

  async generateReport(analysisData) {
    try {
      // Try OpenAI first, then Gemini, then fallback
      if (this.openai) {
        return await this.generateOpenAIReport(analysisData);
      } else if (this.gemini) {
        return await this.generateGeminiReport(analysisData);
      } else {
        return this.generateMockReport(analysisData);
      }
    } catch (error) {
      console.error('Error generating report:', error);
      return this.generateMockReport(analysisData);
    }
  }

  async generateOpenAIReport(analysisData) {
    const prompt = this.buildPrompt(analysisData);
    
    const completion = await this.openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are an expert environmental analyst specializing in satellite imagery interpretation. Generate professional, detailed reports that are accessible to both technical and non-technical audiences."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      max_tokens: 1000,
      temperature: 0.7
    });

    return {
      source: 'OpenAI GPT-4',
      report: completion.choices[0].message.content,
      timestamp: new Date().toISOString()
    };
  }

  async generateGeminiReport(analysisData) {
    const prompt = this.buildPrompt(analysisData);
    const model = this.gemini.getGenerativeModel({ model: "gemini-pro" });
    
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    return {
      source: 'Google Gemini Pro',
      report: text,
      timestamp: new Date().toISOString()
    };
  }

  generateMockReport(analysisData) {
    const { coordinates, area, current_detections, change_analysis, environmental_summary } = analysisData;
    
    let report = `# Satellite Analysis Report\n\n`;
    report += `**Location:** ${area}\n`;
    report += `**Coordinates:** ${coordinates.join(', ')}\n`;
    report += `**Analysis Date:** ${new Date().toLocaleDateString()}\n\n`;
    
    report += `## Executive Summary\n\n`;
    report += `${environmental_summary}\n\n`;
    
    if (current_detections && current_detections.length > 0) {
      report += `## Object Detection Results\n\n`;
      report += `Total objects detected: **${current_detections.length}**\n\n`;
      
      // Group by object type
      const objectTypes = {};
      current_detections.forEach(det => {
        const type = det.class;
        if (!objectTypes[type]) objectTypes[type] = [];
        objectTypes[type].push(det);
      });
      
      Object.entries(objectTypes).forEach(([type, detections]) => {
        const avgConfidence = detections.reduce((sum, det) => sum + det.confidence, 0) / detections.length;
        report += `- **${type}**: ${detections.length} instances (avg confidence: ${(avgConfidence * 100).toFixed(1)}%)\n`;
      });
    }
    
    if (change_analysis && change_analysis.change_detected) {
      report += `\n## Change Detection Analysis\n\n`;
      report += `**Significant changes detected** between time periods:\n\n`;
      
      Object.entries(change_analysis.changes).forEach(([objectType, change]) => {
        const direction = change.change > 0 ? 'increased' : 'decreased';
        report += `- **${objectType}**: ${direction} by ${Math.abs(change.change)} (${change.change_percent.toFixed(1)}% change)\n`;
      });
    }
    
    report += `\n## Environmental Impact Assessment\n\n`;
    report += `This analysis provides valuable insights into the environmental characteristics and human activity patterns in the specified area. `;
    report += `The detected objects and any observed changes can inform environmental monitoring, urban planning, and conservation efforts.\n\n`;
    
    report += `*Report generated by Satellite Data Summarizer AI*\n`;
    
    return {
      source: 'Mock Generation (No API Key)',
      report: report,
      timestamp: new Date().toISOString()
    };
  }

  buildPrompt(analysisData) {
    const { coordinates, area, current_detections, change_analysis, environmental_summary } = analysisData;
    
    return `Generate a professional environmental analysis report based on the following satellite imagery analysis:

Location: ${area}
Coordinates: ${coordinates.join(', ')}

Environmental Summary: ${environmental_summary}

Object Detection Results:
${current_detections ? current_detections.map(det => 
  `- ${det.class}: confidence ${(det.confidence * 100).toFixed(1)}%`
).join('\n') : 'No objects detected'}

${change_analysis && change_analysis.change_detected ? `
Change Detection Analysis:
${Object.entries(change_analysis.changes).map(([type, change]) => 
  `- ${type}: ${change.change > 0 ? 'increased' : 'decreased'} by ${Math.abs(change.change)} (${change.change_percent.toFixed(1)}%)`
).join('\n')}
` : ''}

Please generate a comprehensive report that includes:
1. Executive summary
2. Detailed analysis of detected objects and their environmental significance
3. Change detection insights (if applicable)
4. Environmental impact assessment
5. Recommendations for monitoring or further analysis

Make the report professional, accessible to both technical and non-technical audiences, and focus on environmental and conservation implications.`;
  }

  async generatePDFReport(reportData) {
    // This would integrate with a PDF generation library
    // For now, return the report as markdown
    return {
      format: 'markdown',
      content: reportData.report,
      filename: `satellite_report_${new Date().toISOString().split('T')[0]}.md`
    };
  }
}

module.exports = new ReportService(); 